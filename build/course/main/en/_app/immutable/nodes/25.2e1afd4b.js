import{s as L,n as S,o as z}from"../chunks/scheduler.37c15a92.js";import{S as H,i as M,g as c,s as p,r as j,A,h as m,f as n,c as u,j as k,u as q,x as $,k as E,y as F,a,v as R,d as I,t as O,w as U}from"../chunks/index.2bf4358c.js";import{H as W}from"../chunks/Heading.8ada512a.js";function B(b){let s,h,f,g,i,v,o,P="In this chapter, we explored the essential components of fine-tuning language models:",_,l,T="<li><p><strong>Chat Templates</strong> provide structure to model interactions, ensuring consistent and appropriate responses through standardized formatting.</p></li> <li><p><strong>Supervised Fine-Tuning (SFT)</strong> allows adaptation of pre-trained models to specific tasks while maintaining their foundational knowledge.</p></li> <li><p><strong>LoRA</strong> offers an efficient approach to fine-tuning by reducing trainable parameters while preserving model performance.</p></li> <li><p><strong>Evaluation</strong> helps measure and validate the effectiveness of fine-tuning through various metrics and benchmarks.</p></li>",w,r,y="These techniques, when combined, enable the creation of specialized language models that can excel at specific tasks while remaining computationally efficient. Whether youâ€™re building a customer service bot or a domain-specific assistant, understanding these concepts is crucial for successful model adaptation.",x,d,C;return i=new W({props:{title:"Conclusion",local:"conclusion",headingTag:"h1"}}),{c(){s=c("meta"),h=p(),f=c("p"),g=p(),j(i.$$.fragment),v=p(),o=c("p"),o.textContent=P,_=p(),l=c("ol"),l.innerHTML=T,w=p(),r=c("p"),r.textContent=y,x=p(),d=c("p"),this.h()},l(e){const t=A("svelte-u9bgzb",document.head);s=m(t,"META",{name:!0,content:!0}),t.forEach(n),h=u(e),f=m(e,"P",{}),k(f).forEach(n),g=u(e),q(i.$$.fragment,e),v=u(e),o=m(e,"P",{"data-svelte-h":!0}),$(o)!=="svelte-lf9zjh"&&(o.textContent=P),_=u(e),l=m(e,"OL",{"data-svelte-h":!0}),$(l)!=="svelte-1ovk2di"&&(l.innerHTML=T),w=u(e),r=m(e,"P",{"data-svelte-h":!0}),$(r)!=="svelte-1ej5160"&&(r.textContent=y),x=u(e),d=m(e,"P",{}),k(d).forEach(n),this.h()},h(){E(s,"name","hf:doc:metadata"),E(s,"content",D)},m(e,t){F(document.head,s),a(e,h,t),a(e,f,t),a(e,g,t),R(i,e,t),a(e,v,t),a(e,o,t),a(e,_,t),a(e,l,t),a(e,w,t),a(e,r,t),a(e,x,t),a(e,d,t),C=!0},p:S,i(e){C||(I(i.$$.fragment,e),C=!0)},o(e){O(i.$$.fragment,e),C=!1},d(e){e&&(n(h),n(f),n(g),n(v),n(o),n(_),n(l),n(w),n(r),n(x),n(d)),n(s),U(i,e)}}}const D='{"title":"Conclusion","local":"conclusion","sections":[],"depth":1}';function G(b){return z(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Q extends H{constructor(s){super(),M(this,s,G,B,L,{})}}export{Q as component};
